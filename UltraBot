const path = require('path')

  var antikick = `false`
  function rebirth() {
    // this : || is IMPORTANT
  
    

// HOSTER IS HOST

// PORTER IS PORT
    var hoster = 'localhost'
    var porter = `1075`





    var constantgotopos = null
    var constantgotopos1x = null
    var constantgotopos1y = null
    var constantgotopos1z = null
    var iskillaura = `false`
    var allowedtosetcontrolstate = `true`
    var isallowedtomine = null
    var isactivating = `false`
    var protectiontarget1 = null
    var isprotecting = `false`
    var Magnet = `false`
    var guardPos = null
    var isguarding = null
    var canattack = null
    let target = null
    
    const armorManager = require('mineflayer-armor-manager')
    const pvp = require('mineflayer-pvp').plugin
    const { read } = require('fs')
    const mineflayer = require('mineflayer')
    const { pathfinder, Movements, goals } = require('mineflayer-pathfinder')
    const { on } = require('events')
    const internal = require('stream')
    const { brotliCompress } = require('zlib')
    const GoalFollow = goals.GoalFollow
    
    const settings = {
      host: hoster,
      port: porter,
      username: 'sleepy.lama2008@gmail.com',
      password: '!?Leon?!2008',
      auth: 'microsoft'
      
    }
    function stopGuarding () {
      bot.canDigBlock = true
      guardPos = null
      bot.pvp.stop()
      bot.pathfinder.setGoal(null)
    }
    
    
    const bot = mineflayer.createBot(settings)
    bot.loadPlugin(pvp)
    bot.loadPlugin(armorManager)
    bot.loadPlugin(pathfinder)
    bot.canDigBlock = true
    
    
    
    
    
    
    
    
    function repeaterer() {
      console.clear()
      const readline1 = require('readline').createInterface({
        input: process.stdin,
        output: process.stdout
      })
      
      readline1.question(`
      
      
      What do you want to do? : 

      You can use following commands:

      killaura: attacks EVERYTHING AND YOUT TOO in a 10 block radius

      goto: u have to enter coords WITHOUT , and he will pathfind to it can be out of renderdistance
      
      stopgoto: stops pathfinfing
      
      items: list all inventory items in terminal
      
      mine: 
                gives you two options : 
      
                1st one : run (mines the whole chunk the bot is standing in)
      
                2nd one : stop (stops chunkmining and rejoins)
                
      
                
                Antikick: you can set it to true of false if true the bot will rejoin after ~4 seconds on kick
      
      
      protect: follows the player and attacks mobs if they are in a range of 12
      
      follow: follows the entered player)
      
      attack: runs towards the named target (player) and attacks him until he is dead
      
      come: type come and the name of the player to follow cant be out of renderdistance!
      
      spam: says or executes a message as often you want
      
      kill: kills the named target you will enter
      
      drop: asks you what item and drops you a stack of it!
      
      guard: guards the nearby area where you said the command and kills entities if there is anyone nearby
      
      equip: equip  the item you entered
      
      block: use the item in the offhand like a shield
      
      unblock: stop using the item in the offhand
      
      activate: right clicks the nearest mob
      
      gotoblock: goes to the given block perfectly and mines it


      SCROLL UP
      
      COMMAND : `, msg => {
        if (msg === 'kill') { readline1.close()
          
          const readline2 = require('readline').createInterface({
            input: process.stdin,
            output: process.stdout
          })
          
          readline2.question(`Who is the target? `, msg1 => {
            bot.chat('/kill ' + msg1)
            bot.chat('/ekill ' + msg1)
            readline2.close()
            repeaterer()
          }) 
        }
        
    
    
        else if (msg === 'equip') {
        readline1.close() 
        const readline9 = require('readline').createInterface({
          input: process.stdin,
          output: process.stdout
        })
    
        readline9.question(`What do you want to equip? : `, msg5 => {
          const itemtoequip = bot.inventory.items().find(item => item.name.includes(msg5))
          readline9.close()
          if (itemtoequip) bot.equip(itemtoequip, 'hand')
          repeaterer()
        }) 
        }
    
        else if (msg === 'drop') {
          readline1.close()
          const readline10 = require('readline').createInterface({
            input: process.stdin,
            output: process.stdout
          })
          
          readline10.question(`What item do you want to be dropped? : `, msg6 => {
            const itemtodrop = bot.inventory.items().find(item => item.name.includes(msg6))
            readline10.close()
            if (itemtodrop) {
              var anzahl = '1'
              for (; anzahl < 100; anzahl++) {
              //action here
              bot.tossStack(itemtodrop,1000)
              }
              
            }
            bot.swingArm('right')
            repeaterer()
          }) 
        }

        else if(msg === `killaura`) {
          console.clear()
          readline1.close()
            const readline20 = require('readline').createInterface({
              input: process.stdin,
              output: process.stdout
            })
            
            readline20.question(`\n \n It will attack everything in a 10 block radius even you do u want to toggle?\n\n Y MEANS true\n N MEANS FALSE\n\n Y/N? : `, togglequest => {
              readline20.close()
              if (togglequest === `Y`) {
                iskillaura = `true`
                repeaterer()
              }
              else if (togglequest === `N`) {
                iskillaura = `false`
                repeaterer()
              }
            }) 
          }
    
        else if (msg === `activate`) {
          readline1.close()
          isactivating = `true`
          repeaterer()
        }
        else if (msg === "attack") {
          readline1.close()
          const readline5 = require('readline').createInterface({
            input: process.stdin,
            output: process.stdout
          })
          
          readline5.question(`What player do you want to be attack by me? : `, msg3 => {
            const target1 = bot.players[msg3].entity        
            if (!target1) return
            else if (target1) {
              bot.pvp.attackRange = 3
              bot.pvp.attack(target1, true)
            }
            readline5.close()
            repeaterer()
          }) 
    
        }
    
        else if (msg === `killall`) {
          readline1.close()
          const plrs = bot.players
          var anzahl = '1'
          for (const player of Object.values(bot.players)) { bot.chat(`/execute at ${player.username} run summon tnt`) }
          repeaterer()
        }
    
        else if (msg === `items`) {
          readline1.close()
          function itemToString (item) {
            if (item) {
              return `${item.name} x ${item.count}`
            } else {
              return '(nothing)'
            }
          }
          console.log(`I have these items: ${bot.inventory.items().map(itemToString).join(', ')}`)
          setTimeout(() => {
            repeaterer()
          }, 5000);
    
        }
        
        else if (msg === `protect`) {
          readline1.close()
          const readline14 = require('readline').createInterface({
            input: process.stdin,
            output: process.stdout
          })
          
          readline14.question(`Who do you want me to protect? : \n`, protectiontarget => {
            protectiontarget1 = protectiontarget
            isprotecting = `true`
            readline14.close()
            repeaterer()
          }) 
        }

        else if (msg === `antikick`) {
          readline1.close()
         

          console.clear()
          const readline170 = require('readline').createInterface({
            input: process.stdin,
            output: process.stdout
          })
          
          readline170.question(`On/Off? : `, antikicking => {
            readline170.close()
            if (antikicking === `On`) {
              antikick = `true`
            }
            else if (antikicking === `Off`) {
              antikick = `false`
            }
            repeaterer()

          }) 
        }
    
        else if (msg === 'help') {
          readline1.close()
          console.clear()
          console.log(`killaura: attacks EVERYTHING AND YOUT TOO in a 10 block radius`)
          console.log(`goto: u have to enter coords WITHOUT , and he will pathfind to it can be out of renderdistance`)
          console.log(`stopgoto: stops pathfinfing`)
          console.log(`items: list all inventory items in terminal`)
          console.log(`mine: 
          gives you two options : 

          1st one : run (mines the whole chunk the bot is standing in)

          2nd one : stop (stops chunkmining and rejoins)
          
          `)

          console.log(`
          
          Antikick: you can set it to true of false if true the bot will rejoin after ~4 seconds on kick

          `)
          console.log(`protect: follows the player and attacks mobs if they are in a range of 12`)
          console.log(`follow: follows the entered player`)
          console.log('attack: ' + 'runs towards the named target (player) and attacks him until he is dead')
          console.log('come: ' + 'type come and the name of the player to follow cant be out of renderdistance!')
          console.log('spam: ' + 'says or executes a message as often you want')
          console.log('kill: ' + 'kills the named target you will enter')
          console.log('drop: ' + 'asks you what item and drops you a stack of it!')
          console.log('guard: ' + 'guards the nearby area where you said the command and kills entities if there is anyone nearby')
          console.log('equip: ' + 'equip  the item you entered')
          console.log(`block: use the item in the offhand like a shield`)
          console.log(`unblock: stop using the item in the offhand`)
          console.log(`activate: right clicks the nearest mob`)
          console.log(`gotoblock: goes to the given block perfectly and mines it`)
          const readline18 = require('readline').createInterface({
            input: process.stdin,
            output: process.stdout
          })
          
          readline18.question(`\n Press any key to continue..`, keytocontin => {
            readline18.close()
            repeaterer()
          }) 
        }
    
        else if (msg === "spam") {
          readline1.close()
          const readline7 = require('readline').createInterface({
            input: process.stdin,
            output: process.stdout
          })
          
          readline7.question(`How often do you want the message to be repeated? : ` ,anzahl => {
            readline1.close()
            readline7.close()
    
            const readline11 = require('readline').createInterface({
              input: process.stdin,
              output: process.stdout
            })
            
            readline11.question(`What's the position? (leave blank if u dont want to enter pos) \n`, typedposition => {
              readline11.close()
              readline7.close()
              const readline8 = require('readline').createInterface({
                input: process.stdin,
                output: process.stdout
              })
              readline8.question(`Whats the message you want to send? : `, nachrich => {
    
                var stazahl = 0
                const typedposition1 = typedposition
                for (; stazahl < anzahl; stazahl++) {
                  //action here
                  bot.chat(nachrich + ` ${typedposition1}`)
                  }
            readline8.close()
            repeaterer()
            }) 
    
    
    
    
            }) 
          }) 
        }
        
        else if (msg === 'guard') {
          guardPos = bot.entity.position
          isguarding = `true`
          readline1.close()
          repeaterer()
        }
    
        else if (msg === 'stop') {
          bot.canDigBlock = true
          stopGuarding()
          isguarding = false
          readline1.close()
          repeaterer()
        }
    
    
    
        else if (msg === 'gotoblock') {
    
          readline1.close()
          const readline15 = require('readline').createInterface({
            input: process.stdin,
            output: process.stdout
          })
          
          readline15.question(`What's the name of the block? : \n`, targetblock11 => {
            function locatetargetBlock () {
              bot.loadPlugin(pathfinder)
              const GoalBlock = goals.GoalBlock
              const mcData = require('minecraft-data')(bot.version)
              const movements = new Movements(bot, mcData)
              movements.scafoldingBlocks = []
              bot.pathfinder.setMovements(movements)
            
              const targetBlock = bot.findBlock({
                  matching: mcData.blocksByName[targetblock11].id,
                  maxDistance: 319
              })
            
              if (!targetBlock) {
                  bot.chat(`I can't see any ${targetblock11} blocks!`)
                  return
              }
            
              const x1 = targetBlock.position.x
              const y1 = targetBlock.position.y + 1
              const z1 = targetBlock.position.z
              const goal3 = new GoalBlock(x1, y1, z1)
              bot.pathfinder.setGoal(goal3)
              bot.once(`goal_reached`, () => {
                const pickaxe = bot.inventory.items().find(item => item.name.includes(`pickaxe`))
                if (pickaxe) {
                  bot.equip(pickaxe)
                }
                bot.dig(bot.blockAt(bot.entity.position.offset(0, -1 ,0)),true)
              })
            }
    
            locatetargetBlock()
    
            readline15.close()
            repeaterer()
            
          }) 
    
          
        }
        
        else if (msg === `mine`) {
          readline1.close()
          function chunkminerer() {
          
          
          const Vec3 = require('vec3').Vec3;
          const minecraftData = require("minecraft-data")("1.18.2")
          
          
          
          bot.loadPlugin(pathfinder)
          
          let botState = "resting"
          let target
          
          bot.once("spawn", async () => {
              bot.waitForChunksToLoad().then(() => {
                      // containerToInventory(bot.blockAt(new Vec3(57, 56, 78)), minecraftData.itemsByName.birch_planks.id, 32)
                  // console.log(minecraftData.itemsByName.ladder.id, bot.inventory.slots)
              })
          })
          
            const readline16 = require('readline').createInterface({
              input: process.stdin,
              output: process.stdout
            })
            
            readline16.question(`What do you wanna do? : `, whataction => {
              readline1.close()
              readline16.close()
              if (whataction === `run`) {
                  switch (whataction) {
                      case "run": {
                        isallowedtomine = `true`
                          console.log(`running`)
                          botState = "running"
                          bot.waitForChunksToLoad().then(() => {
                              main()
                          })
                          break
                      }
            
                      case "follow": {
                          botState = "following"
                          bot.chat("following")
                          const followGoal = new goals.GoalFollow(bot.players[whataction].entity)
                          const followMovement = new Movements(bot, minecraftData)
                          bot.pathfinder.setMovements(followMovement)
                          bot.pathfinder.setGoal(followGoal)
                          break
                      }
            
                      case "stop": {
                        isallowedtomine = `false`
                          try {
                              bot.chat("stopped")
                              botState = "resting"
                              bot.stopDigging()
                              bot.pathfinder.stop()
                              bot.pathfinder.setGoal(null)
            
                          } catch (e) {
                              console.warn(e)
                          }
                          // process.exit(0)
                          break
                      }
            
                      case "chunk": {
                          
                          break
                      }
            
                      case "state": {
                          bot.chat(botState)
                          break
                      }
            
            
                  }
            
              }
              else if (whataction === `stop`) {
                readline16.close()
                readline1.close()
                isallowedtomine = `false`
                setTimeout(() => {
                  rebirth()
                }, 100);
              }
            
              async function main() {
              let cornerPos = getChunkCorner(bot.entity.position)
              target = cornerPos[1];
              while (target != cornerPos[0]) {
                if (isallowedtomine === `true`) {
                  await searchChunk(target, cornerPos[0], cornerPos[1])
                  await go()
                  await dig()
                }
                else return
          
              }
              }
            
            
              async function go() {
            
              if (botState == "resting") bot.pathfinder.stop()
            
              const digGoal = new goals.GoalGetToBlock(target.x, target.y, target.z)
              const digMovement = new Movements(bot, minecraftData)
              await bot.equip(bot.pathfinder.bestHarvestTool(bot.blockAt(target)), "hand")
            
              await bot.pathfinder.setMovements(digMovement)
              await bot.pathfinder.goto(digGoal)
              }
            
              async function dig() {
              // console.log(target)
              
              try {
          
                  await bot.dig(bot.world.getBlock(target))
            
              } catch (e) {
                  
              }
              }
            
              /*WARNING: YOU ARE NOT EXPECTED TO UNDERSTAND THIS
              * true is real to fake, false is fake to real
              * */
              function magicVec3Transfer(startPos, endPos, inputPos, type) {
            
              return type ?
                  new Vec3(
                      Math.abs(inputPos.x) - Math.abs(startPos.x),
                      inputPos.y,
                      Math.abs(inputPos.z) - Math.abs(startPos.z)) :
                  new Vec3(
                      startPos.x > 0 ? 0 + (inputPos.x + Math.abs(startPos.x)) : 0 - (inputPos.x + Math.abs(startPos.x)),
                      inputPos.y,
                      startPos.z > 0 ? 0 + (inputPos.z + Math.abs(startPos.z)) : 0 - (inputPos.z + Math.abs(startPos.z)),)
              }
            
            
              async function searchChunk(nowPos, startPos, endPos) {
              // console.log("start", startPos)
              // console.log("end", endPos)
              // console.log("now", nowPos)
            
              let magicStartPos = magicVec3Transfer(startPos, endPos, startPos, true),
                  magicEndPos = magicVec3Transfer(startPos, endPos, endPos, true),
                  magicNowPos = magicVec3Transfer(startPos, endPos, nowPos, true)
            
              for (; magicNowPos.y >= magicStartPos.y; magicNowPos.y--)
                  for (magicNowPos.x = magicEndPos.x; magicNowPos.x >= magicStartPos.x; magicNowPos.x--)
                      for (magicNowPos.z = magicEndPos.z; magicNowPos.z >= magicStartPos.z; magicNowPos.z--) {
            
            
                          nowPos = magicVec3Transfer(startPos, endPos, magicNowPos, false)
                          // console.log(nowPos)
                          // console.log(bot.world.getBlock(nowPos))
                          if (botState == "resting") return nowPos
          
                          if (bot.blockAt(nowPos).name === `bedrock`) {
                           isallowedtomine = `true`
                          }
                          if (
                              bot.blockAt(nowPos) != null &&
                              bot.blockAt(nowPos).name != "air"
                              // pathfinder.safeToBreak(bot.blockAt(nowPos))
                          ) {
                              //console.log("Target Found")
                              // console.log(nowPos)
                              target = nowPos
                              return nowPos
                          }
                      }
              }
            
              function getChunkCorner(pos) {
              let startPos = new Vec3((pos.x) - pos.x % 16, -64, pos.z - pos.z % 16)
              let endPos = new Vec3((startPos.x > 0) ? startPos.x + 15 : startPos.x - 15, 128, (startPos.z > 0) ? startPos.z + 15 : startPos.z - 15)
              return [startPos, endPos]
              }
              
            
              
            }) 
            
            
            
              
          }
          chunkminerer()
          
          
    
    
    
        }
        else if (msg === "follow") {
          readline1.close()
          const readline6 = require('readline').createInterface({
            input: process.stdin,
            output: process.stdout
          })
          
          readline6.question(`What player am i ordered to follow? : `, msg4 => {
            bot.loadPlugin(pathfinder)
            function followPlayer() {
              bot.canDigBlock = false
                const playerr = bot.players[msg4]
    
                if (!playerr) {
                    bot.chat("I can't see " + msg4 + '!')
                    return
                }
    
                const mcData = require('minecraft-data')(bot.version)
                const movements = new Movements(bot, mcData)
    
    
                bot.pathfinder.setMovements(movements)
    
                const goal = new GoalFollow(playerr.entity, 1)
                bot.pathfinder.setGoal(goal, true)
            }
            followPlayer()
            readline6.close()
            repeaterer()
          }) 
    
        }
        else if (msg === `magnet`) {
          readline1.close()
          const readline13 = require('readline').createInterface({
            input: process.stdin,
            output: process.stdout
          })
          
          readline13.question(`On or Off? \n \n `, onoroff => {
            readline13.close()
            if (onoroff === `On`) {
              Magnet = `true`
            }
            else if (onoroff === `Off`) {
              Magnet = `false`
            }
            repeaterer()
            
          }) 
        }

        else if (msg === `goto`) {
          readline1.close()
          const readline19 = require('readline').createInterface({
            input: process.stdin,
            output: process.stdout
          })
          
          readline19.question(`Position? : `, whatpos => {
            readline19.close()
            function locategoto () {
              var Vec3 = require('vec3').Vec3;
              bot.loadPlugin(pathfinder)
              const mcData = require('minecraft-data')(bot.version)
        
              bot.pathfinder.setMovements(new Movements(bot, mcData))
              var cmd = whatpos.split(` `)
              console.log(cmd[1])
              const x = cmd[0]
              const y = cmd[1]
              const z = cmd[2]

              const goal111 = (whatpos)
              bot.pathfinder.setGoal(new goals.GoalBlock(x,y,z))
              constantgotopos1x = x
              constantgotopos1y = y
              constantgotopos1z = z
          }
          
          locategoto()
          repeaterer()
          }) 
        }

        else if (msg === `stopgoto`) {
          readline1.close()
          bot.pathfinder.setGoal(null)
          bot.pathfinder.stop()
          repeaterer()
        }
    
        else if (msg === `block`) {
          readline1.close()
          bot.activateItem(true)
          repeaterer()
        }
    
        else if (msg === `unblock`) {
          readline1.close()
          bot.deactivateItem()
          repeaterer()
        }
    
        else if (msg === `stop protect`) {
          readline1.close()
          protectiontarget1 = null
          isprotecting = `false`
          repeaterer()
        } 
        else if (msg === 'stop follow') {
          readline1.close()
          bot.loadPlugin(pathfinder)
          bot.pathfinder.stop()
          repeaterer()
        }
        
        else {
          bot.chat(msg)
          readline1.close()
          console.clear()
          repeaterer()
        }
        
      })
    }
    
    bot.once(`spawn`, () =>{
      setInterval(() => {
        const mobfilter = (entity) => entity.type === 'mob'
        const nearestmobber = bot.nearestEntity()
        if (isactivating === `true`) {
          if (nearestmobber) {
            if (bot.entity.position.distanceTo(nearestmobber.position) < 10) {
              bot.activateEntity(nearestmobber, nearestmobber.position)
            }
            else return
          }
    
        }
    
      }, 1000);
    })
    
    
    function moveToGuardPos () {
      const mcData = require('minecraft-data')(bot.version)
      bot.pathfinder.setMovements(new Movements(bot, mcData))
      bot.pathfinder.setGoal(new goals.GoalBlock(guardPos.x, guardPos.y, guardPos.z))
    }
    
    
    
    bot.once('spawn', repeaterer)
    
        
    
    
    bot.on('chat', (username, message) => {
    
      if (username === bot.username) {
        
      }
      else {
        console.log(username + ': ' + message)
      }
    })
    
    
    
    bot.on(`death`, () => {
      setTimeout(() => {
        console.clear()
      }, 1000);
      
    })
    
    
    
    
    
    
    setInterval(() => {
      if (isguarding === `true`) {
        var playerFilter1 = (entity) => entity.type === 'mob'
        const nearestmob = bot.nearestEntity(playerFilter1)
        if (!nearestmob) return
        
        else if (isguarding === `false`) {
          const itemtoequip = bot.inventory.items().find(item => item.name.includes(``))
          if (itemtoequip) bot.unequip(itemtoequip, 'hand')
        }
        
        else if (bot.entity.position.distanceTo(nearestmob.position) < 12) {
          bot.canDigBlock = false
          playerFilter1 = (entity) => entity.type === 'mob'
          const itemtoequip = bot.inventory.items().find(item => item.name.includes(`sword`))
          if (itemtoequip) bot.equip(itemtoequip, 'hand')
          bot.pvp.attack(nearestmob, true)
        }
      }
    }, 10);
    
    
    
    
    
    bot.on(`stoppedAttacking`,()=> {
        console.log(constantgotopos1x,constantgotopos1y,constantgotopos1z)
        const mcData = require('minecraft-data')(bot.version)
        bot.pathfinder.setMovements(new Movements(bot, mcData))
        bot.pathfinder.setGoal(new goals.GoalBlock(constantgotopos1x,constantgotopos1y,constantgotopos1z))
    })
    
    
    bot.on('stoppedAttacking', () => {
      if (guardPos) {
        moveToGuardPos()
      }
    })
    
    
    
    bot.on('physicTick', () => {
      if (bot.pvp.target) return
      if (bot.pathfinder.isMoving()) return
    
      const entity = bot.nearestEntity()
      if (entity) bot.lookAt(entity.position.offset(0, entity.height, 0))
    })
    
    
    setInterval(() => {
      if (Magnet === `true`) {
        bot.chat(`/tp @e[type=!item,type=!minecraft:player,distance=..30] ~ ~5 ~`)
      }
      else if (Magnet === `false`) {
    
      }
    }, 10);
    
    bot.once(`spawn`, () => {
      setInterval(() => {
        if (isprotecting === `true`) {
          bot.loadPlugin(pathfinder)
          const mybotentity = bot.entity
          function followPlayer10() {
              const playerCI = bot.players[protectiontarget1]
    
              if (!playerCI || !playerCI.entity) {
                  return
              }
    
              const mcData = require('minecraft-data')(bot.version)
              const movements = new Movements(bot, mcData)
              movements.scafoldingBlocks = []
    
              bot.pathfinder.setMovements(movements)
    
              const goal = new GoalFollow(playerCI.entity, 1)
              bot.pathfinder.setGoal(goal)
          }
          followPlayer10()
          bot.loadPlugin(pvp)
          const entityFilter = (entity) => entity.type === `mob`
          if (bot.health < 4) {
            bot.pvp.stop()
            return
          }
          
          
    
          else if (bot.nearestEntity(entityFilter)) {
            if (mybotentity && bot.entity.position.distanceTo(bot.nearestEntity(entityFilter).position) < 12) {
              const nearestentitty = bot.nearestEntity(entityFilter)
              const itemtoequip = bot.inventory.items().find(item => item.name.includes(`sword`))
              if (itemtoequip) bot.equip(itemtoequip, 'hand')
              const itemtoequip1 = bot.inventory.items().find(item => item.name.includes(`shield`))
              if (itemtoequip1) bot.equip(itemtoequip1, 'off-hand')
            }
          }
    
    
    
        }
    
        else if (isprotecting === `false`) {
    
        }
      }, 500);
    })
    
    
    bot.once(`spawn`, () =>{
      setInterval(() => {
        const mobfilter = (entity) => entity.type === `mob`
        if (isprotecting === `true`) {
          if (bot.nearestEntity(mobfilter)) {
            if (bot.entity && bot.entity.position.distanceTo(bot.nearestEntity(mobfilter).position) < 12) {
              bot.loadPlugin(pvp)
              bot.pvp.attackRange = 3.4
              bot.pvp.attack(bot.nearestEntity(mobfilter), true)
            }
            else return
          }
          }
    
      }, 100);
    })
    
    bot.once(`spawn`, () => {
    setInterval( checkifentitynear => {
      const mobfilter = (entity) => entity.type === `mob`
      if (bot.nearestEntity(mobfilter)) {
        if (bot.entity.position.distanceTo(bot.nearestEntity(mobfilter).position) < 4) {
          bot.activateItem(true)
        }
        else if (bot.entity.position.distanceTo(bot.nearestEntity(mobfilter).position) > 8) {
          bot.deactivateItem()
        }
      }
      
    }, 100);
    })
    
    
    
    
    bot.on(`entityCrouch`, () => {
      const hasentity = bot.entity
      const nearestplayer = bot.nearestEntity((entity) => entity.type === `player`)
      if (nearestplayer && bot.entity) {
        if (nearestplayer.position.distanceTo(bot.entity.position) < 4)  {
          bot.setControlState(`sneak`, true)
        }
      }
    })

    bot.on(`entityUncrouch`, () => {
      const hasentity = bot.entity
      const nearestplayer = bot.nearestEntity((entity) => entity.type === `player`)
      if (nearestplayer && bot.entity) {
        if (nearestplayer.position.distanceTo(bot.entity.position)  < 4) {
          bot.setControlState(`sneak`, false)
        }
      }
    })
    
    
bot.once(`spawn`, () => {
  setInterval(() => {
    if (allowedtosetcontrolstate === `true`) {
      const mobfilterer = bot.nearestEntity((entity) => entity.type === `player`)
      if (mobfilterer) {
        if (mobfilterer.position.distanceTo(bot.entity.position) > 4) {
          bot.setControlState(`sneak`, false)
         } 
      }

    }

  }, 100);
})
    
    
    
    
    
bot.once(`spawn`,() => {
  setInterval(() => {
    if (iskillaura === `true`) {
      bot.loadPlugin(pvp)
      if (bot.entity) {
        if (bot.nearestEntity) {
          if (bot.nearestEntity((entity) => entity.type === `player`)){
            if (bot.nearestEntity((entity) => entity.type === `player`).position.distanceTo(bot.entity.position) < 15){
              console.log(`DETECTED PLAYER`)
              setTimeout(() => {
                console.clear()
              }, 100);
              bot.pvp.attack(bot.nearestEntity((entity) => entity.type === `player`),false)
              const itemtoequip = bot.inventory.items().find(item => item.name.includes(`sword`))
              if (itemtoequip) bot.equip(itemtoequip, 'hand')
            }
          }          
        }
      }
    }
  }, 100);

  setInterval(() => {
    if (iskillaura === `true`) {
      bot.loadPlugin(pvp)
      if (bot.entity) {
        if (bot.nearestEntity) {
          if (bot.nearestEntity((entity) => entity.type === `mob`)){
            if (bot.nearestEntity((entity) => entity.type === `mob`).position.distanceTo(bot.entity.position) < 10){
              console.log(`DETECTED MOB`)
              setTimeout(() => {
                console.clear()
              }, 100);
              bot.pvp.attack(bot.nearestEntity((entity) => entity.type === `mob`),true)
              const itemtoequip = bot.inventory.items().find(item => item.name.includes(`sword`))
              if (itemtoequip) bot.equip(itemtoequip, 'hand')
            }
          }          
        }
      }
    }
  }, 100);
})


    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
   bot.on(`kicked`, () =>{
     if (antikick === `true`) {
     setTimeout(() => {     
       rebirth()
     }, 6000);   
     }
     else if (antikick === `false`) {
       console.clear()
       console.log(`I got kicked!`)
     }
   }) 
  }
  rebirth()

  

