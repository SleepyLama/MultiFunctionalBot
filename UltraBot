const path = require('path')

  var antikick = `false`
  function rebirth() {
    // this : || is IMPORTANT
  
    

// HOSTER IS HOST

// PORTER IS PORT
    var hoster = 'localhost'
    var porter = `1075`





    var constantgotopos = null
    var constantgotopos1x = null
    var constantgotopos1y = null
    var constantgotopos1z = null
    var iskillaura = `false`
    var allowedtosetcontrolstate = `true`
    var isallowedtomine = null
    var isactivating = `false`
    var protectiontarget1 = null
    var isprotecting = `false`
    var Magnet = `false`
    var guardPos = null
    var isguarding = null
    var canattack = null
    let target = null
    
    const armorManager = require('mineflayer-armor-manager')
    const pvp = require('mineflayer-pvp').plugin
    const { read } = require('fs')
    const mineflayer = require('mineflayer')
    const { pathfinder, Movements, goals } = require('mineflayer-pathfinder')
    const { on } = require('events')
    const internal = require('stream')
    const { brotliCompress } = require('zlib')
    const GoalFollow = goals.GoalFollow
    
    const settings = {
      host: hoster,
      port: porter,
      username: 'sleepy.lama2008@gmail.com',
      password: '!?Leon?!2008',
      auth: 'microsoft'
      
    }
    function stopGuarding () {
      bot.canDigBlock = true
      guardPos = null
      bot.pvp.stop()
      bot.pathfinder.setGoal(null)
    }
    
    
    const bot = mineflayer.createBot(settings)
    bot.loadPlugin(pvp)
    bot.loadPlugin(armorManager)
    bot.loadPlugin(pathfinder)
    bot.canDigBlock = true
    
    
    
    
    
    
    
    
    function repeaterer() {
      console.clear()
      const readline1 = require('readline').createInterface({
        input: process.stdin,
        output: process.stdout
      })
      
      readline1.question(`
      
      
      What do you want to do? : 

      You can use following commands:

      killaura: attacks EVERYTHING AND YOUT TOO in a 10 block radius
      goto: u have to enter coords WITHOUT , and he will pathfind to it can be out of renderdistance
      stopgoto: stops pathfinfing
      items: list all inventory items in terminal
      
      mine: 
          gives you two options : 
      
          1st one : run (mines the whole chunk the bot is standing in)
      
          2nd one : stop (stops chunkmining and rejoins)
                       
      Antikick: you can set it to true of false if true the bot will rejoin after ~4 seconds on kick
      protect: follows the player and attacks mobs if they are in a range of 12
      follow: follows the entered player)
      attack: runs towards the named target (player) and attacks him until he is dead
      come: type come and the name of the player to follow cant be out of renderdistance!
      spam: says or executes a message as often you want
      kill: kills the named target you will enter
      drop: asks you what item and drops you a stack of it!
      guard: guards the nearby area where you said the command and kills entities if there is anyone nearby
      equip: equip  the item you entered
      block: use the item in the offhand like a shield
      unblock: stop using the item in the offhand
      activate: right clicks the nearest mob
      gotoblock: goes to the given block perfectly and mines it

      IF YOU DONT ENTER ANY OF THESE COMMANDS THE BOT WILL JUST SAY IT IN CHAT YES COMMANDS WORKS TOO 

      SCROLL UP
      
      COMMAND : `, msg => {
        if (msg === 'kill') { readline1.close()
          
          const readline2 = require('readline').createInterface({
            input: process.stdin,
            output: process.stdout
          })
          
          readline2.question(`Who is the target? `, msg1 => {
            bot.chat('/kill ' + msg1)
            bot.chat('/ekill ' + msg1)
            readline2.close()
            repeaterer()
          }) 
        }
        
    
    
        else if (msg === 'equip') {
        readline1.close() 
        const readline9 = require('readline').createInterface({
          input: process.stdin,
          output: process.stdout
        })
    
        readline9.question(`What do you want to equip? : `, msg5 => {
          const itemtoequip = bot.inventory.items().find(item => item.name.includes(msg5))
          readline9.close()
          if (itemtoequip) bot.equip(itemtoequip, 'hand')
          repeaterer()
        }) 
        }
    
        else if (msg === 'drop') {
          readline1.close()
          const readline10 = require('readline').createInterface({
            input: process.stdin,
            output: process.stdout
          })
          
          readline10.question(`What item do you want to be dropped? : `, msg6 => {
            const itemtodrop = bot.inventory.items().find(item => item.name.includes(msg6))
            readline10.close()
            if (itemtodrop) {
              var anzahl = '1'
              for (; anzahl < 100; anzahl++) {
              //action here
              bot.tossStack(itemtodrop,1000)
              }
              
            }
            bot.swingArm('right')
            repeaterer()
          }) 
        }

        else if(msg === `killaura`) {
          console.clear()
          readline1.close()
            const readline20 = require('readline').createInterface({
              input: process.stdin,
              output: process.stdout
            })
            
            readline20.question(`\n \n It will attack everything in a 10 block radius even you do u want to toggle?\n\n Y MEANS true\n N MEANS FALSE\n\n Y/N? : `, togglequest => {
              readline20.close()
              if (togglequest === `Y`) {
                iskillaura = `true`
                repeaterer()
              }
              else if (togglequest === `N`) {
                iskillaura = `false`
                repeaterer()
              }
            }) 
          }
    
        else if (msg === `activate`) {
          readline1.close()
          isactivating = `true`
          repeaterer()
        }
        else if (msg === "attack") {
          readline1.close()
          const readline5 = require('readline').createInterface({
            input: process.stdin,
            output: process.stdout
          })
          
          readline5.question(`What player do you want to be attack by me? : `, msg3 => {
            const target1 = bot.players[msg3].entity        
            if (!target1) return
            else if (target1) {
              bot.pvp.attackRange = 3
              bot.pvp.attack(target1, true)
            }
            readline5.close()
            repeaterer()
          }) 
    
        }
    
        else if (msg === `killall`) {
          readline1.close()
          const plrs = bot.players
          var anzahl = '1'
          for (const player of Object.values(bot.players)) { bot.chat(`/execute at ${player.username} run summon tnt`) }
          repeaterer()
        }
    
        else if (msg === `items`) {
          readline1.close()
          function itemToString (item) {
            if (item) {
              return `${item.name} x ${item.count}`
            } else {
              return '(nothing)'
            }
          }
          console.log(`I have these items: ${bot.inventory.items().map(itemToString).join(', ')}`)
          setTimeout(() => {
            repeaterer()
          }, 5000);
    
        }
        
        else if (msg === `protect`) {
          readline1.close()
          const readline14 = require('readline').createInterface({
            input: process.stdin,
            output: process.stdout
          })
          
          readline14.question(`Who do you want me to protect? : \n`, protectiontarget => {
            protectiontarget1 = protectiontarget
            isprotecting = `true`
            readline14.close()
            repeaterer()
          }) 
        }

        else if (msg === `antikick`) {
          readline1.close()
         

          console.clear()
          const readline170 = require('readline').createInterface({
            input: process.stdin,
            output: process.stdout
          })
          
          readline170.question(`On/Off? : `, antikicking => {
            readline170.close()
            if (antikicking === `On`) {
              antikick = `true`
            }
            else if (antikicking === `Off`) {
              antikick = `false`
            }
            repeaterer()

          }) 
        }
    
        else if (msg === 'help') {
          readline1.close()
          console.clear()
          console.log(`killaura: attacks EVERYTHING AND YOUT TOO in a 10 block radius`)
          console.log(`goto: u have to enter coords WITHOUT , and he will pathfind to it can be out of renderdistance`)
          console.log(`stopgoto: stops pathfinfing`)
          console.log(`items: list all inventory items in terminal`)
          console.log(`mine: 
          gives you two options : 

          1st one : run (mines the whole chunk the bot is standing in)

          2nd one : stop (stops chunkmining and rejoins)
          
          `)

          console.log(`
          
          Antikick: you can set it to true of false if true the bot will rejoin after ~4 seconds on kick

          `)
          console.log(`protect: follows the player and attacks mobs if they are in a range of 12`)
          console.log(`follow: follows the entered player`)
          console.log('attack: ' + 'runs towards the named target (player) and attacks him until he is dead')
          console.log('come: ' + 'type come and the name of the player to follow cant be out of renderdistance!')
          console.log('spam: ' + 'says or executes a message as often you want')
          console.log('kill: ' + 'kills the named target you will enter')
          console.log('drop: ' + 'asks you what item and drops you a stack of it!')
          console.log('guard: ' + 'guards the nearby area where you said the command and kills entities if there is anyone nearby')
          console.log('equip: ' + 'equip  the item you entered')
          console.log(`block: use the item in the offhand like a shield`)
          console.log(`unblock: stop using the item in the offhand`)
          console.log(`activate: right clicks the nearest mob`)
          console.log(`gotoblock: goes to the given block perfectly and mines it`)
          const readline18 = require('readline').createInterface({
            input: process.stdin,
            output: process.stdout
          })
          
          readline18.question(`\n Press any key to continue..`, keytocontin => {
            readline18.close()
            repeaterer()
          }) 
        }
    
        else if (msg === "spam") {
          readline1.close()
          const readline7 = require('readline').createInterface({
            input: process.stdin,
            output: process.stdout
          })
          
          readline7.question(`How often do you want the message to be repeated? : ` ,anzahl => {
            readline1.close()
            readline7.close()
    
            const readline11 = require('readline').createInterface({
              input: process.stdin,
              output: process.stdout
            })
            
            readline11.question(`What's the position? (leave blank if u dont want to enter pos) \n`, typedposition => {
              readline11.close()
              readline7.close()
              const readline8 = require('readline').createInterface({
                input: process.stdin,
                output: process.stdout
              })
              readline8.question(`Whats the message you want to send? : `, nachrich => {
    
                var stazahl = 0
                const typedposition1 = typedposition
                for (; stazahl < anzahl; stazahl++) {
                  //action here
                  bot.chat(nachrich + ` ${typedposition1}`)
                  }
            readline8.close()
            repeaterer()
            }) 
    
    
    
    
            }) 
          }) 
        }
        
        else if (msg === 'guard') {
          guardPos = bot.entity.position
          isguarding = `true`
          readline1.close()
          repeaterer()
        }
    
        else if (msg === 'stop') {
          bot.canDigBlock = true
          stopGuarding()
          isguarding = false
          readline1.close()
          repeaterer()
        }
    
    
    
        else if (msg === 'gotoblock') {
    
          readline1.close()
          const readline15 = require('readline').createInterface({
            input: process.stdin,
            output: process.stdout
          })
          
          readline15.question(`What's the name of the block? : \n`, targetblock11 => {
            function locatetargetBlock () {
              bot.loadPlugin(pathfinder)
              const GoalBlock = goals.GoalBlock
              const mcData = require('minecraft-data')(bot.version)
              const movements = new Movements(bot, mcData)
              movements.scafoldingBlocks = []
              bot.pathfinder.setMovements(movements)
            
              const targetBlock = bot.findBlock({
                  matching: mcData.blocksByName[targetblock11].id,
                  maxDistance: 319
              })
            
              if (!targetBlock) {
                  bot.chat(`I can't see any ${targetblock11} blocks!`)
                  return
              }
            
              const x1 = targetBlock.position.x
              const y1 = targetBlock.position.y + 1
              const z1 = targetBlock.position.z
              const goal3 = new GoalBlock(x1, y1, z1)
              bot.pathfinder.setGoal(goal3)
              bot.once(`goal_reached`, () => {
                const pickaxe = bot.inventory.items().find(item => item.name.includes(`pickaxe`))
                if (pickaxe) {
                  bot.equip(pickaxe)
                }
                bot.dig(bot.blockAt(bot.entity.position.offset(0, -1 ,0)),true)
              })
            }
    
            locatetargetBlock()
    
            readline15.close()
            repeaterer()
            
          }) 
    
          
        }
        
        else if (msg === `mine`) {
          readline1.close()
          function chunkminerer() {
          
          
          const Vec3 = require('vec3').Vec3;
          const minecraftData = require("minecraft-data")("1.18.2")
          
          
          
          bot.loadPlugin(pathfinder)
          
          let botState = "resting"
          let target
          
          bot.once("spawn", async () => {
              bot.waitForChunksToLoad().then(() => {
                      // containerToInventory(bot.blockAt(new Vec3(57, 56, 78)), minecraftData.itemsByName.birch_planks.id, 32)
                  // console.log(minecraftData.itemsByName.ladder.id, bot.inventory.slots)
              })
          })
          
            const readline16 = require('readline').createInterface({
              input: process.stdin,
              output: process.stdout
            })
            
            readline16.question(`What do you wanna do? : `, whataction => {
              readline1.close()
              readline16.close()
              if (whataction === `run`) {
                  switch (whataction) {
                      case "run": {
                        isallowedtomine = `true`
                          console.log(`running`)
                          botState = "running"
                          bot.waitForChunksToLoad().then(() => {
                              main()
                          })
                          break
                      }
            
                      case "follow": {
                          botState = "following"
                          bot.chat("following")
                          const followGoal = new goals.GoalFollow(bot.players[whataction].entity)
                          const followMovement = new Movements(bot, minecraftData)
                          bot.pathfinder.setMovements(followMovement)
                          bot.pathfinder.setGoal(followGoal)
                          break
                      }
            
                      case "stop": {
                        isallowedtomine = `false`
                          try {
                              bot.chat("stopped")
                              botState = "resting"
                              bot.stopDigging()
                              bot.pathfinder.stop()
                              bot.pathfinder.setGoal(null)
            
                          } catch (e) {
                              console.warn(e)
                          }
                          // process.exit(0)
                          break
                      }
            
                      case "chunk": {
                          
                          break
                      }
            
                      case "state": {
                          bot.chat(botState)
                          break
                      }
            
            
                  }
            
              }
              else if (whataction === `stop`) {
                readline16.close()
                readline1.close()
                isallowedtomine = `false`
                setTimeout(() => {
                  rebirth()
                }, 100);
              }
            
              async function main() {
              let cornerPos = getChunkCorner(bot.entity.position)
              target = cornerPos[1];
              while (target != cornerPos[0]) {
                if (isallowedtomine === `true`) {
                  await searchChunk(target, cornerPos[0], cornerPos[1])
                  await go()
                  await dig()
                }
                else return
          
              }
              }
            
            
              async function go() {
            
              if (botState == "resting") bot.pathfinder.stop()
            
              const digGoal = new goals.GoalGetToBlock(target.x, target.y, target.z)
              const digMovement = new Movements(bot, minecraftData)
              await bot.equip(bot.pathfinder.bestHarvestTool(bot.blockAt(target)), "hand")
            
              await bot.pathfinder.setMovements(digMovement)
              await bot.pathfinder.goto(digGoal)
              }
            
              async function dig() {
              // console.log(target)
              
              try {
          
                  await bot.dig(bot.world.getBlock(target))
            
              } catch (e) {
                  
              }
              }
            
              /*WARNING: YOU ARE NOT EXPECTED TO UNDERSTAND THIS
              * true is real to fake, false is fake to real
              * */
              function magicVec3Transfer(startPos, endPos, inputPos, type) {
            
              return type ?
                  new Vec3(
                      Math.abs(inputPos.x) - Math.abs(startPos.x),
                      inputPos.y,
                      Math.abs(inputPos.z) - Math.abs(startPos.z)) :
                  new Vec3(
                      startPos.x > 0 ? 0 + (inputPos.x + Math.abs(startPos.x)) : 0 - (inputPos.x + Math.abs(startPos.x)),
                      inputPos.y,
                      startPos.z > 0 ? 0 + (inputPos.z + Math.abs(startPos.z)) : 0 - (inputPos.z + Math.abs(startPos.z)),)
              }
            
            
              async function searchChunk(nowPos, startPos, endPos) {
              // console.log("start", startPos)
              // console.log("end", endPos)
              // console.log("now", nowPos)
            
              let magicStartPos = magicVec3Transfer(startPos, endPos, startPos, true),
                  magicEndPos = magicVec3Transfer(startPos, endPos, endPos, true),
                  magicNowPos = magicVec3Transfer(startPos, endPos, nowPos, true)
            
              for (; magicNowPos.y >= magicStartPos.y; magicNowPos.y--)
                  for (magicNowPos.x = magicEndPos.x; magicNowPos.x >= magicStartPos.x; magicNowPos.x--)
                      for (magicNowPos.z = magicEndPos.z; magicNowPos.z >= magicStartPos.z; magicNowPos.z--) {
            
            
                          nowPos = magicVec3Transfer(startPos, endPos, magicNowPos, false)
                          // console.log(nowPos)
                          // console.log(bot.world.getBlock(nowPos))
                          if (botState == "resting") return nowPos
          
                          if (bot.blockAt(nowPos).name === `bedrock`) {
                           isallowedtomine = `true`
                          }
                          if (
                              bot.blockAt(nowPos) != null &&
                              bot.blockAt(nowPos).name != "air"
                              // pathfinder.safeToBreak(bot.blockAt(nowPos))
                          ) {
                              //console.log("Target Found")
                              // console.log(nowPos)
                              target = nowPos
                              return nowPos
                          }
                      }
              }
            
              function getChunkCorner(pos) {
              let startPos = new Vec3((pos.x) - pos.x % 16, -64, pos.z - pos.z % 16)
              let endPos = new Vec3((startPos.x > 0) ? startPos.x + 15 : startPos.x - 15, 128, (startPos.z > 0) ? startPos.z + 15 : startPos.z - 15)
              return [startPos, endPos]
              }
              
            
              
            }) 
            
            
            
              
          }
          chunkminerer()
          
          
    
    
    
        }
        else if (msg === "follow") {
          readline1.close()
          const readline6 = require('readline').createInterface({
            input: process.stdin,
            output: process.stdout
          })
          
          readline6.question(`What player am i ordered to follow? : `, msg4 => {
            bot.loadPlugin(pathfinder)
            function followPlayer() {
              bot.canDigBlock = false
                const playerr = bot.players[msg4]
    
                if (!playerr) {
                    bot.chat("I can't see " + msg4 + '!')
                    return
                }
    
                const mcData = require('minecraft-data')(bot.version)
                const movements = new Movements(bot, mcData)
    
    
                bot.pathfinder.setMovements(movements)
    
                const goal = new GoalFollow(playerr.entity, 1)
                bot.pathfinder.setGoal(goal, true)
            }
            followPlayer()
            readline6.close()
            repeaterer()
          }) 
    
        }
        else if (msg === `magnet`) {
          readline1.close()
          const readline13 = require('readline').createInterface({
            input: process.stdin,
            output: process.stdout
          })
          
          readline13.question(`On or Off? \n \n `, onoroff => {
            readline13.close()
            if (onoroff === `On`) {
              Magnet = `true`
            }
            else if (onoroff === `Off`) {
              Magnet = `false`
            }
            repeaterer()
            
          }) 
        }

        else if (msg === `goto`) {
          readline1.close()
          const readline19 = require('readline').createInterface({
            input: process.stdin,
            output: process.stdout
          })
          
          readline19.question(`Position? : `, whatpos => {
            readline19.close()
            function locategoto () {
              var Vec3 = require('vec3').Vec3;
              bot.loadPlugin(pathfinder)
              const mcData = require('minecraft-data')(bot.version)
        
              bot.pathfinder.setMovements(new Movements(bot, mcData))
              var cmd = whatpos.split(` `)
              console.log(cmd[1])
              const x = cmd[0]
              const y = cmd[1]
              const z = cmd[2]

              const goal111 = (whatpos)
              bot.pathfinder.setGoal(new goals.GoalBlock(x,y,z))
              constantgotopos1x = x
              constantgotopos1y = y
              constantgotopos1z = z
          }
          
          locategoto()
          repeaterer()
          }) 
        }

        else if (msg === `stopgoto`) {
          readline1.close()
          bot.pathfinder.setGoal(null)
          bot.pathfinder.stop()
          repeaterer()
        }
    
        else if (msg === `block`) {
          readline1.close()
          bot.activateItem(true)
          repeaterer()
        }
    
        else if (msg === `unblock`) {
          readline1.close()
          bot.deactivateItem()
          repeaterer()
        }
    
        else if (msg === `stop protect`) {
          readline1.close()
          protectiontarget1 = null
          isprotecting = `false`
          repeaterer()
        } 
        else if (msg === 'stop follow') {
          readline1.close()
          bot.loadPlugin(pathfinder)
          bot.pathfinder.stop()
          repeaterer()
        }
        
        else {
          bot.chat(msg)
          readline1.close()
          console.clear()
          repeaterer()
        }
        
      })
    }
    
    bot.once(`spawn`, () =>{
      setInterval(() => {
        const mobfilter = (entity) => entity.type === 'mob'
        const nearestmobber = bot.nearestEntity()
        if (isactivating === `true`) {
          if (nearestmobber) {
            if (bot.entity.position.distanceTo(nearestmobber.position) < 10) {
              bot.activateEntity(nearestmobber, nearestmobber.position)
            }
            else return
          }
    
        }
    
      }, 1000);
    })
    
    
    function moveToGuardPos () {
      const mcData = require('minecraft-data')(bot.version)
      bot.pathfinder.setMovements(new Movements(bot, mcData))
      bot.pathfinder.setGoal(new goals.GoalBlock(guardPos.x, guardPos.y, guardPos.z))
    }
    
    
    
    bot.once('spawn', repeaterer)
    
        
    
    
    bot.on('chat', (username, message) => {
    
      if (username === bot.username) {
        
      }
      else {
        console.log(username + ': ' + message)
      }
    })
    
    
    
    bot.on(`death`, () => {
      setTimeout(() => {
        console.clear()
      }, 1000);
      
    })
    
    
    
    
    
    
    setInterval(() => {
      if (isguarding === `true`) {
        var playerFilter1 = (entity) => entity.type === 'mob'
        const nearestmob = bot.nearestEntity(playerFilter1)
        if (!nearestmob) return
        
        else if (isguarding === `false`) {
          const itemtoequip = bot.inventory.items().find(item => item.name.includes(``))
          if (itemtoequip) bot.unequip(itemtoequip, 'hand')
        }
        
        else if (bot.entity.position.distanceTo(nearestmob.position) < 12) {
          bot.canDigBlock = false
          playerFilter1 = (entity) => entity.type === 'mob'
          const itemtoequip = bot.inventory.items().find(item => item.name.includes(`sword`))
          if (itemtoequip) bot.equip(itemtoequip, 'hand')
          bot.pvp.attack(nearestmob, true)
        }
      }
    }, 10);
    
    
    
    
    
    bot.on(`stoppedAttacking`,()=> {
        console.log(constantgotopos1x,constantgotopos1y,constantgotopos1z)
        const mcData = require('minecraft-data')(bot.version)
        bot.pathfinder.setMovements(new Movements(bot, mcData))
        bot.pathfinder.setGoal(new goals.GoalBlock(constantgotopos1x,constantgotopos1y,constantgotopos1z))
    })
    
    
    bot.on('stoppedAttacking', () => {
      if (guardPos) {
        moveToGuardPos()
      }
    })
    
    
    
    bot.on('physicTick', () => {
      if (bot.pvp.target) return
      if (bot.pathfinder.isMoving()) return
    
      const entity = bot.nearestEntity()
      if (entity) bot.lookAt(entity.position.offset(0, entity.height, 0))
    })
    
    
    setInterval(() => {
      if (Magnet === `true`) {
        bot.chat(`/tp @e[type=!item,type=!minecraft:player,distance=..30] ~ ~5 ~`)
      }
      else if (Magnet === `false`) {
    
      }
    }, 10);
    
    bot.once(`spawn`, () => {
      setInterval(() => {
        if (isprotecting === `true`) {
          bot.loadPlugin(pathfinder)
          const mybotentity = bot.entity
          function followPlayer10() {
              const playerCI = bot.players[protectiontarget1]
    
              if (!playerCI || !playerCI.entity) {
                  return
              }
    
              const mcData = require('minecraft-data')(bot.version)
              const movements = new Movements(bot, mcData)
              movements.scafoldingBlocks = []
    
              bot.pathfinder.setMovements(movements)
    
              const goal = new GoalFollow(playerCI.entity, 1)
              bot.pathfinder.setGoal(goal)
          }
          followPlayer10()
          bot.loadPlugin(pvp)
          const entityFilter = (entity) => entity.type === `mob`
          if (bot.health < 4) {
            bot.pvp.stop()
            return
          }
          
          
    
          else if (bot.nearestEntity(entityFilter)) {
            if (mybotentity && bot.entity.position.distanceTo(bot.nearestEntity(entityFilter).position) < 12) {
              const nearestentitty = bot.nearestEntity(entityFilter)
              const itemtoequip = bot.inventory.items().find(item => item.name.includes(`sword`))
              if (itemtoequip) bot.equip(itemtoequip, 'hand')
              const itemtoequip1 = bot.inventory.items().find(item => item.name.includes(`shield`))
              if (itemtoequip1) bot.equip(itemtoequip1, 'off-hand')
            }
          }
    
    
    
        }
    
        else if (isprotecting === `false`) {
    
        }
      }, 500);
    })
    
    
    bot.once(`spawn`, () =>{
      setInterval(() => {
        const mobfilter = (entity) => entity.type === `mob`
        if (isprotecting === `true`) {
          if (bot.nearestEntity(mobfilter)) {
            if (bot.entity && bot.entity.position.distanceTo(bot.nearestEntity(mobfilter).position) < 12) {
              bot.loadPlugin(pvp)
              bot.pvp.attackRange = 3.4
              bot.pvp.attack(bot.nearestEntity(mobfilter), true)
            }
            else return
          }
          }
    
      }, 100);
    })
    
    bot.once(`spawn`, () => {
    setInterval( checkifentitynear => {
      const mobfilter = (entity) => entity.type === `mob`
      if (bot.nearestEntity(mobfilter)) {
        if (bot.entity.position.distanceTo(bot.nearestEntity(mobfilter).position) < 4) {
          bot.activateItem(true)
        }
        else if (bot.entity.position.distanceTo(bot.nearestEntity(mobfilter).position) > 8) {
          bot.deactivateItem()
        }
      }
      
    }, 100);
    })
    
    
    
    
    bot.on(`entityCrouch`, () => {
      const hasentity = bot.entity
      const nearestplayer = bot.nearestEntity((entity) => entity.type === `player`)
      if (nearestplayer && bot.entity) {
        if (nearestplayer.position.distanceTo(bot.entity.position) < 4)  {
          bot.setControlState(`sneak`, true)
        }
      }
    })

    bot.on(`entityUncrouch`, () => {
      const hasentity = bot.entity
      const nearestplayer = bot.nearestEntity((entity) => entity.type === `player`)
      if (nearestplayer && bot.entity) {
        if (nearestplayer.position.distanceTo(bot.entity.position)  < 4) {
          bot.setControlState(`sneak`, false)
        }
      }
    })
    
    
bot.once(`spawn`, () => {
  setInterval(() => {
    if (allowedtosetcontrolstate === `true`) {
      const mobfilterer = bot.nearestEntity((entity) => entity.type === `player`)
      if (mobfilterer) {
        if (mobfilterer.position.distanceTo(bot.entity.position) > 4) {
          bot.setControlState(`sneak`, false)
         } 
      }

    }

  }, 100);
})
    
    
    
    
    
bot.once(`spawn`,() => {
  setInterval(() => {
    if (iskillaura === `true`) {
      bot.loadPlugin(pvp)
      if (bot.entity) {
        if (bot.nearestEntity) {
          if (bot.nearestEntity((entity) => entity.type === `player`)){
            if (bot.nearestEntity((entity) => entity.type === `player`).position.distanceTo(bot.entity.position) < 15){
              console.log(`DETECTED PLAYER`)
              setTimeout(() => {
                console.clear()
              }, 100);
              bot.pvp.attack(bot.nearestEntity((entity) => entity.type === `player`),false)
              const itemtoequip = bot.inventory.items().find(item => item.name.includes(`sword`))
              if (itemtoequip) bot.equip(itemtoequip, 'hand')
            }
          }          
        }
      }
    }
  }, 100);

  setInterval(() => {
    if (iskillaura === `true`) {
      bot.loadPlugin(pvp)
      if (bot.entity) {
        if (bot.nearestEntity) {
          if (bot.nearestEntity((entity) => entity.type === `mob`)){
            if (bot.nearestEntity((entity) => entity.type === `mob`).position.distanceTo(bot.entity.position) < 10){
              console.log(`DETECTED MOB`)
              setTimeout(() => {
                console.clear()
              }, 100);
              bot.pvp.attack(bot.nearestEntity((entity) => entity.type === `mob`),true)
              const itemtoequip = bot.inventory.items().find(item => item.name.includes(`sword`))
              if (itemtoequip) bot.equip(itemtoequip, 'hand')
            }
          }          
        }
      }
    }
  }, 100);
})


    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
   bot.on(`kicked`, () =>{
     if (antikick === `true`) {
     setTimeout(() => {     
       rebirth()
     }, 6000);   
     }
     else if (antikick === `false`) {
       console.clear()
       console.log(`I got kicked!`)
     }
   }) 
  }
  rebirth()

  

